---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhengnan.
--- DateTime: 2018/6/20 16:29
---

local LuaObject = require("Betel.LuaObject")
---@class List : Betel.LuaObject
---@field New fun(table:table<number, any>) : List
local List = class("List",LuaObject)

local function Operator(list)
    local mt = getmetatable(list).__index
    setmetatable(list,
{__index = function (t,k)
        if type(k) == "number" and mt.At then
            return mt.At(t,k)
        end
    end})
end

function List:Ctor(table)
    List.super.Ctor(self, table)
    Operator(self)
    self._array = table and table or {}
end

function List:GetArray()
    return self._array
end

function List:Clear()
    self._array = nil
    self._array = {}
end

function List:Size()
    return  #self._array
end

function List:Insert(item, pos)
    if pos <= 0 then
        logError("List out of range")
    elseif pos >= #self._array then
        table.insert(self._array,item)
    else
        table.insert(self._array,pos,item)
    end
end

function List:RemoveAt(idx)
    return table.remove(self._array,idx)
end

--在列表末尾添加一个数据项，
-- UnShift() Push()的等价操作
function List:Add(item)
    table.insert(self._array,item)
end

--在列表末尾添加一个数据项，
function List:UnShift(item)
    table.insert(self._array,1, item)
end

--在列表末尾添加一个数据项，
function List:Push(item)
    table.insert(self._array,item)
end

--列表删除列表首位数据项
function List:Shift()
    return table.remove(self._array,1)
end

--列表首位数据项
function List:Peek()
    if #self._array == 0 then
        --logError("List is Empty")
        return nil
    end
    return self._array[1]
end

--列表末位数据项
function List:Tail()
    if #self._array == 0 then
        logError("List is Empty")
    end
    return self._array[#self._array]
end
--
function List:Pop()
    return table.remove(self._array,#self._array)
end

function List:Remove(item)
    if nil == item then
        logError("List remove a item that is not nil")
        return 0
    else
        for i = 1,#self._array do
            if self._array[i] == item then
                table.remove(self._array, i)
                return i
            end
        end
    end
    return 0
end

function List:IndexOf(item)
    if nil == item then
        logError("List index of a item that is not nil")
    else
        for i = 1,#self._array do
            if self._array[i] == item then
                return i
            end
        end
    end
    return -1
end

function List:Contain(item)
    if nil == item then
        logError("List contain a item that is not nil")
        return false
    else
        for i = 1,#self._array do
            if self._array[i] == item then
                return true
            end
        end
    end
    return false
end

function List:At(idx)
    if idx <= 0 or idx > #self._array then
        logError("Index out of range. index")
        return false
    end
    return self._array[idx]
end

function List:Concat(other)
    if nil == other then
        logError("List Concat a other is not nil")
    else
        for i = 1,#other._array do
            table.insert(self._array,other._array[i])
        end
    end
end

function List:Clone()
    local newList = List.New()
    newList:Concat(self)
    return newList
end


function List:Reverse()
    local newList = List.New()
    for i = 1, self:Size() do
        newList:Push(self:Pop())
    end
    return newList
end

function List:Sort(compFunc)
    table.sort(self._array,compFunc)
end

function List:SortClone(compFunc)
    local newList = self:Clone()
    return newList:Sort(compFunc)
end
return List

